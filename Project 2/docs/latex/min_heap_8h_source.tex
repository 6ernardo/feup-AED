\hypertarget{min_heap_8h_source}{}\doxysection{min\+Heap.\+h}
\mbox{\hyperlink{min_heap_8h}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{// AED 2021/2022 -\/ Aula Pratica 11}}
\DoxyCodeLine{2 \textcolor{comment}{// Pedro Ribeiro (DCC/FCUP) [17/01/2022]}}
\DoxyCodeLine{3 }
\DoxyCodeLine{4 \textcolor{preprocessor}{\#ifndef \_MINHEAP\_H\_}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#define \_MINHEAP\_H\_}}
\DoxyCodeLine{6 }
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <vector>}}
\DoxyCodeLine{8 \textcolor{preprocessor}{\#include <unordered\_map>}}
\DoxyCodeLine{9 }
\DoxyCodeLine{10 \textcolor{preprocessor}{\#define LEFT(i) (2*(i))}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#define RIGHT(i) (2*(i)+1)}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#define PARENT(i) ((i)/2)}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{keyword}{using namespace }std;}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{comment}{// Binary min-\/heap to represent integer keys of type K with values (priorities) of type V}}
\DoxyCodeLine{17 \textcolor{keyword}{template} <\textcolor{keyword}{class} K, \textcolor{keyword}{class} V>}
\DoxyCodeLine{18 \textcolor{keyword}{class }\mbox{\hyperlink{class_min_heap}{MinHeap}} \{}
\DoxyCodeLine{19     \textcolor{keyword}{struct }Node \{ \textcolor{comment}{// An element of the heap: a pair (key, value)}}
\DoxyCodeLine{20         K key;}
\DoxyCodeLine{21         V value;}
\DoxyCodeLine{22     \};}
\DoxyCodeLine{23 }
\DoxyCodeLine{24     \textcolor{keywordtype}{int} size;                  \textcolor{comment}{// Number of elements in heap}}
\DoxyCodeLine{25     \textcolor{keywordtype}{int} maxSize;               \textcolor{comment}{// Maximum number of elements in heap}}
\DoxyCodeLine{26     vector<Node> a;            \textcolor{comment}{// The heap array}}
\DoxyCodeLine{27     unordered\_map<K, int> pos; \textcolor{comment}{// maps a key into its position on the array a}}
\DoxyCodeLine{28     \textcolor{keyword}{const} K KEY\_NOT\_FOUND;}
\DoxyCodeLine{29 }
\DoxyCodeLine{30     \textcolor{keywordtype}{void} upHeap(\textcolor{keywordtype}{int} i);}
\DoxyCodeLine{31     \textcolor{keywordtype}{void} downHeap(\textcolor{keywordtype}{int} i);}
\DoxyCodeLine{32     \textcolor{keywordtype}{void} swap(\textcolor{keywordtype}{int} i1, \textcolor{keywordtype}{int} i2);}
\DoxyCodeLine{33 }
\DoxyCodeLine{34 \textcolor{keyword}{public}:}
\DoxyCodeLine{35 }
\DoxyCodeLine{41     \mbox{\hyperlink{class_min_heap_a8041a62441509d4fd713e3b1bfad8f31}{MinHeap}}(\textcolor{keywordtype}{int} n, \textcolor{keyword}{const} K\& notFound);}
\DoxyCodeLine{42 }
\DoxyCodeLine{47     \textcolor{keywordtype}{int} \mbox{\hyperlink{class_min_heap_a17652e042dae3954be25a1cd9e04f3b0}{getSize}}();}
\DoxyCodeLine{48 }
\DoxyCodeLine{54     \textcolor{keywordtype}{bool} \mbox{\hyperlink{class_min_heap_ae5bd0efd391f31ed67634d5eeb50622e}{hasKey}}(\textcolor{keyword}{const} K\& key);}
\DoxyCodeLine{55 }
\DoxyCodeLine{61     \textcolor{keywordtype}{void} \mbox{\hyperlink{class_min_heap_a708cab4630ba761be49aea0ae536d772}{insert}}(\textcolor{keyword}{const} K\& key, \textcolor{keyword}{const} V\& value);}
\DoxyCodeLine{62 }
\DoxyCodeLine{68     \textcolor{keywordtype}{void} \mbox{\hyperlink{class_min_heap_acb40738ccbaf73f7c093f8504387587b}{decreaseKey}}(\textcolor{keyword}{const} K\& key, \textcolor{keyword}{const} V\& value);}
\DoxyCodeLine{69 }
\DoxyCodeLine{74     K \mbox{\hyperlink{class_min_heap_a3ab07802846cc4314d7ec383180d3b82}{removeMin}}(); \textcolor{comment}{// remove and return key with smaller value}}
\DoxyCodeLine{75 \};}
\DoxyCodeLine{76 }
\DoxyCodeLine{77 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{78 }
\DoxyCodeLine{79 \textcolor{comment}{// Make a value go "{}up the tree"{} until it reaches its position}}
\DoxyCodeLine{80 \textcolor{keyword}{template} <\textcolor{keyword}{class} K, \textcolor{keyword}{class} V>}
\DoxyCodeLine{81 \textcolor{keywordtype}{void} \mbox{\hyperlink{class_min_heap}{MinHeap<K,V>::upHeap}}(\textcolor{keywordtype}{int} i) \{}
\DoxyCodeLine{82     \textcolor{keywordflow}{while} (i>1 \&\& a[i].value < a[\mbox{\hyperlink{min_heap_8h_a91004761621b8ef1c66f3601988fde7c}{PARENT}}(i)].value) \{ \textcolor{comment}{// while pos smaller than parent, keep swapping to upper position}}
\DoxyCodeLine{83         swap(i, \mbox{\hyperlink{min_heap_8h_a91004761621b8ef1c66f3601988fde7c}{PARENT}}(i));}
\DoxyCodeLine{84         i = \mbox{\hyperlink{min_heap_8h_a91004761621b8ef1c66f3601988fde7c}{PARENT}}(i);}
\DoxyCodeLine{85     \}}
\DoxyCodeLine{86 \}}
\DoxyCodeLine{87 }
\DoxyCodeLine{88 \textcolor{comment}{// Make a value go "{}down the tree"{} until it reaches its position}}
\DoxyCodeLine{89 \textcolor{keyword}{template} <\textcolor{keyword}{class} K, \textcolor{keyword}{class} V>}
\DoxyCodeLine{90 \textcolor{keywordtype}{void} \mbox{\hyperlink{class_min_heap}{MinHeap<K,V>::downHeap}}(\textcolor{keywordtype}{int} i) \{}
\DoxyCodeLine{91     \textcolor{keywordflow}{while} (\mbox{\hyperlink{min_heap_8h_a25d5ae2e52c533b5f27895fcf7a4ea95}{LEFT}}(i) <= size) \{ \textcolor{comment}{// while within heap limits}}
\DoxyCodeLine{92         \textcolor{keywordtype}{int} j = \mbox{\hyperlink{min_heap_8h_a25d5ae2e52c533b5f27895fcf7a4ea95}{LEFT}}(i);}
\DoxyCodeLine{93         \textcolor{keywordflow}{if} (\mbox{\hyperlink{min_heap_8h_a134d4f19a207929c1e9716743771ae5a}{RIGHT}}(i)<=size \&\& a[\mbox{\hyperlink{min_heap_8h_a134d4f19a207929c1e9716743771ae5a}{RIGHT}}(i)].value < a[j].value) j = \mbox{\hyperlink{min_heap_8h_a134d4f19a207929c1e9716743771ae5a}{RIGHT}}(i); \textcolor{comment}{// choose smaller child}}
\DoxyCodeLine{94         \textcolor{keywordflow}{if} (a[i].value < a[j].value) \textcolor{keywordflow}{break};   \textcolor{comment}{// node already smaller than children, stop}}
\DoxyCodeLine{95         swap(i, j);                    \textcolor{comment}{// otherwise, swap with smaller child}}
\DoxyCodeLine{96         i = j;}
\DoxyCodeLine{97     \}}
\DoxyCodeLine{98 \}}
\DoxyCodeLine{99 }
\DoxyCodeLine{100 \textcolor{comment}{// Swap two positions of the heap (update their positions)}}
\DoxyCodeLine{101 \textcolor{keyword}{template} <\textcolor{keyword}{class} K, \textcolor{keyword}{class} V>}
\DoxyCodeLine{102 \textcolor{keywordtype}{void} \mbox{\hyperlink{class_min_heap}{MinHeap<K,V>::swap}}(\textcolor{keywordtype}{int} i1, \textcolor{keywordtype}{int} i2) \{}
\DoxyCodeLine{103     Node tmp = a[i1]; a[i1] = a[i2]; a[i2] = tmp;}
\DoxyCodeLine{104     pos[a[i1].key] = i1;}
\DoxyCodeLine{105     pos[a[i2].key] = i2;}
\DoxyCodeLine{106 \}}
\DoxyCodeLine{107 }
\DoxyCodeLine{108 \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{109 }
\DoxyCodeLine{110 \textcolor{comment}{// Create a min-\/heap for a max of n pairs (K,V) with notFound returned when empty}}
\DoxyCodeLine{111 \textcolor{keyword}{template} <\textcolor{keyword}{class} K, \textcolor{keyword}{class} V>}
\DoxyCodeLine{112 \mbox{\hyperlink{class_min_heap_a8041a62441509d4fd713e3b1bfad8f31}{MinHeap<K,V>::MinHeap}}(\textcolor{keywordtype}{int} n, \textcolor{keyword}{const} K\& notFound) : KEY\_NOT\_FOUND(notFound), size(0), maxSize(n), a(n+1) \{}
\DoxyCodeLine{113 \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115 \textcolor{comment}{// Return number of elements in the heap}}
\DoxyCodeLine{116 \textcolor{keyword}{template} <\textcolor{keyword}{class} K, \textcolor{keyword}{class} V>}
\DoxyCodeLine{117 \textcolor{keywordtype}{int} \mbox{\hyperlink{class_min_heap_a17652e042dae3954be25a1cd9e04f3b0}{MinHeap<K,V>::getSize}}() \{}
\DoxyCodeLine{118     \textcolor{keywordflow}{return} size;}
\DoxyCodeLine{119 \}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121 \textcolor{comment}{// Heap has key?}}
\DoxyCodeLine{122 \textcolor{keyword}{template} <\textcolor{keyword}{class} K, \textcolor{keyword}{class} V>}
\DoxyCodeLine{123 \textcolor{keywordtype}{bool} \mbox{\hyperlink{class_min_heap_ae5bd0efd391f31ed67634d5eeb50622e}{MinHeap<K, V>::hasKey}}(\textcolor{keyword}{const} K\& key) \{}
\DoxyCodeLine{124     \textcolor{keywordflow}{return} pos.find(key) != pos.end();}
\DoxyCodeLine{125 \}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127 \textcolor{comment}{// Insert (key, value) on the heap}}
\DoxyCodeLine{128 \textcolor{keyword}{template} <\textcolor{keyword}{class} K, \textcolor{keyword}{class} V>}
\DoxyCodeLine{129 \textcolor{keywordtype}{void} \mbox{\hyperlink{class_min_heap_a708cab4630ba761be49aea0ae536d772}{MinHeap<K,V>::insert}}(\textcolor{keyword}{const} K\& key, \textcolor{keyword}{const} V\& value) \{}
\DoxyCodeLine{130     \textcolor{keywordflow}{if} (size == maxSize) \textcolor{keywordflow}{return}; \textcolor{comment}{// heap is full, do nothing}}
\DoxyCodeLine{131     \textcolor{keywordflow}{if} (hasKey(key)) \textcolor{keywordflow}{return};     \textcolor{comment}{// key already exists, do nothing}}
\DoxyCodeLine{132     a[++size] = \{key, value\};}
\DoxyCodeLine{133     pos[key] = size;}
\DoxyCodeLine{134     upHeap(size);}
\DoxyCodeLine{135 \}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 \textcolor{comment}{// Decrease value of key to the indicated value}}
\DoxyCodeLine{138 \textcolor{keyword}{template} <\textcolor{keyword}{class} K, \textcolor{keyword}{class} V>}
\DoxyCodeLine{139 \textcolor{keywordtype}{void} \mbox{\hyperlink{class_min_heap_acb40738ccbaf73f7c093f8504387587b}{MinHeap<K,V>::decreaseKey}}(\textcolor{keyword}{const} K\& key, \textcolor{keyword}{const} V\& value) \{}
\DoxyCodeLine{140     \textcolor{keywordflow}{if} (!hasKey(key)) \textcolor{keywordflow}{return}; \textcolor{comment}{// key does not exist, do nothing}}
\DoxyCodeLine{141     \textcolor{keywordtype}{int} i = pos[key];}
\DoxyCodeLine{142     \textcolor{keywordflow}{if} (value > a[i].value) \textcolor{keywordflow}{return}; \textcolor{comment}{// value would increase, do nothing}}
\DoxyCodeLine{143     a[i].value = value;}
\DoxyCodeLine{144     upHeap(i);}
\DoxyCodeLine{145 \}}
\DoxyCodeLine{146 }
\DoxyCodeLine{147 \textcolor{comment}{// remove and return key with smaller value}}
\DoxyCodeLine{148 \textcolor{keyword}{template} <\textcolor{keyword}{class} K, \textcolor{keyword}{class} V>}
\DoxyCodeLine{149 K \mbox{\hyperlink{class_min_heap_a3ab07802846cc4314d7ec383180d3b82}{MinHeap<K,V>::removeMin}}() \{}
\DoxyCodeLine{150     \textcolor{keywordflow}{if} (size == 0) \textcolor{keywordflow}{return} KEY\_NOT\_FOUND;}
\DoxyCodeLine{151     K min = a[1].key;}
\DoxyCodeLine{152     pos.erase(min);}
\DoxyCodeLine{153     a[1] = a[size-\/-\/];}
\DoxyCodeLine{154     downHeap(1);}
\DoxyCodeLine{155     \textcolor{keywordflow}{return} min;}
\DoxyCodeLine{156 \}}
\DoxyCodeLine{157 }
\DoxyCodeLine{158 \textcolor{preprocessor}{\#endif}}

\end{DoxyCode}
